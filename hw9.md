# 作业九
<center>
    蔡合森 2022K8009009004
</center>

**9.1** 假设一台计算机上运行的一个进程其地址空间有8个虚页（每个虚页大小为4KB，页号为1至8），操作系统给该进程分配了4个物理页框（每个页框大小为4KB），该进程对地址空间中虚页的访问顺序为 1 2 4 5 6 3 7 3 7 8。假设分配给进程的4个物理页框初始为空，请计算：
（1）如果操作系统采用CLOCK算法管理内存，那么该进程访存时会发生多少次page fault？当进程访问完上述虚页后，物理页框中保存的是哪些虚页？
（2）如果操作系统采用LRU算法管理内存，请再次回答（1）中的两个问题。请回答虚页保存情况时，写出LRU链的组成，标明LRU端和MRU端。
**解**：
（1）
所给物理页框可存放至多4个虚页，初始状态为空，则读入首4个不同页时皆会发生page fault，此时页框内存储情况为：

| 1    | 2    | 4    | 5    |
| ---- | ---- | ---- | ---- |

此时再访问虚页6，未存储在已有物理页框内，发生page fault，并进行页替换，第一圈全部为变为0，第二圈换出第一个

| 6    | 2    | 4    | 5    |
| ---- | ---- | ---- | ---- |

再访问虚页3，发生page fault，换出第二个；

| 6    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- |

再访问虚页7，发生page fault，换出第三个；

| 6    | 3    | 7    | 5    |
| ---- | ---- | ---- | ---- |

再访问虚页3，7；hit

| 6    | 3    | 7    | 5    |
| ---- | ---- | ---- | ---- |

再访问虚页3，发生page fault，换出第四个；

| 6    | 3    | 7    | 8    |
| ---- | ---- | ---- | ---- |

故一共发生4+1+1+1+1=8次页错误，最后保存的是6 3 7 8虚页。

（2）
同样，读入首4个不同页时皆会发生page fault，此时页框内存储情况为：

| 1    | 2    | 4    | 5    |
| ---- | ---- | ---- | ---- |

此时再访问虚页6，未存储在已有物理页框内，发生page fault，并进行页替换，最近最少使用的是首个页，替换得：

| 6    | 2    | 4    | 5    |
| ---- | ---- | ---- | ---- |

再访问虚页3，发生page fault，并进行页替换，最近最少使用的是第二个页，替换得：

| 6    | 3    | 4    | 5    |
| ---- | ---- | ---- | ---- |

再访问虚页7，发生page fault并进行页替换，最近最少使用的是第三個頁，替换：

| 6    | 3    | 7    | 	5   |
| ---- | ---- | ---- | ---- |

访问虚页3,7,hit


访问虚页8，发生page fault，最近最少使用的是第四虚页，替换：

| 6    | 3    | 7	 | 8	|
| ---- | ---- | ---- | ---- |


故一共发生4+1+1+1+1=8次页错误，最后保存的是6 3 7 8虚页。

**9.2**假设一台计算机给每个进程都分配4个物理页框，每个页框大小为1KB。现有一个程序对一个二维整数数组（uint32 X[32][32]）进行赋值操作，该程序的代码段占用一个固定的页框，并一直存储在内存中。程序使用剩余3个物理页框存储数据。该程序操作的数组X以列存储形式保存在磁盘上，即X[0][0]后保存的是X[1][0]、X[2][0]…X[31][0]，然后再保存X[0][1]，以此类推。当程序要赋值时，如果所赋值的数组元素不在内存中，则会触发page fault，操作系统将相应元素以页框粒度交换至内存。如果该进程的物理页框已经用满，则会进行页换出。该程序有如下两种写法。
```C
写法1：
for(int i=0;i<64;i++)
   for(int j=0;j<64;j++)
      X[i][j] = 0
写法2：
for(int j=0;j<64;i++)
   for(int i=0;i<64;j++)
      X[i][j] = 0

```
请分析使用这两种写法时，各自会产生多少次page fault？（注：请写出分析或计算过程）
**解**：
- 寫法一：
    一个页框大小1KB，一个`uint32`类型元素占4B，故一个页框内可存储$\frac{1024}{4}=256$个该类型数据。
    每初始化四次發生一次page fault，那么会发生 $64/4 X 64$ = 1024

- 写法二：
    显然，没初始化256个才会发生page fault;即j每加四发生一次。那么$\frac{64}{4}=16$ 次
**9.3** 假设一个程序有两个段，其中段0保存代码指令，段1保存读写的数据。段0的权限是可读可执行，段1的权限是可读可写，如下所示。该程序运行的内存系统提供的虚址空间为14-bit空间，其中低10-bit为页内偏移，高4-bit为页号。
![
](image-1.png)
当有如下的访存操作时，请给出每个操作的实际访存物理地址或是产生的异常类型（例如缺页异常、权限异常等）
（1）	读取段1中page 1的offset为3的地址
（2）	向段0中page 0的offset为16的地址写入
（3）	读取段1中page 4的offset为28的地址
（4）	跳转至段1中page 3的offset为32的地址

**解**：
+ 段1中page 1已经对应于第14个物理页框，同时段1的权限为可读可写，读操作不会发生异常。其实地址为14N+3；
+ 段0中page 0已经对应于第2个物理页框，但段0的权限为可读可执行，写操作会触发权限异常。其实地址为2N+16；
+ 读取段1中page 4的offset为28的地址，缺页；
+ 1中page 3 已经对应于第6个物理页框，但段1的权限为可读可写行，执行操作会触发权限异常。其实地址为6N+3
| 操作描述 | 实际访存物理地址或异常类型 |
|----------|-----------------------------|
| 读取段1中page 1的offset为3的地址 | 14N+3 |
| 向段0中page 0的offset为16的地址写入 |权限异常 |
| 读取段1中page 4的offset为28的地址 | 缺页异常 |
| 跳转至段1中page 3的offset为32的地址 | 权限异常 |



**9.4**假设一个程序对其地址空间中虚页的访问序列为0,1,2，…,511,422,0,1,2,…,511，333,0,1,2,…，即访问一串连续地址（页0到页511）后会随机访问一个页（页422或页333），且这个访问模式会一直重复。请分析说明：
（1）假设操作系统分配给该程序的物理页框为500个，那么，LRU，Second Chance和FIFO这三种算法中哪一个会表现较好（即提供较高的命中率），或是这三种算法都表现不佳？为什么？
**解**：
+ 这三种表现都不佳，因为在这种访问序列情况下，这三种算法的替换情况大都相同，命中率都不高
+ 表现都不佳的原因是题目中的访问序列是512个数字循环，而物理页框是500，物理页框小于循环的大小，会发生频繁的missing.

**9.5** 现有一个内存空间分配器，采用伙伴算法。假设物理内存总共 64 KB，
1) 请给出第一级的一对伙伴块的起始地址
2) 请给出第二级的二对伙伴块的起始地址
3) 地址 0xa700，已知它位于第 7 级伙伴块中，请问该块的伙伴块的起始地址

**解**：
 一块大小默认512B，64KB对应$2^7$块，即需要8个级别（含第0级的一整块内存）。

 1）第一级的一对伙伴块起始地址：`0x0000 ~ 0x7fff `, `0x8000 ~ 0xffff`;

 2）第二级的两对伙伴块起始地址：`0x0000 ~ 0x3fff `, `0x4000 ~ 0x7fff`;`0x8000 ~ 0xbfff `, `0xc000 ~ 0xffff`;

3）第 7 级伙伴块地址为`512B`对齐的，即最低12位为0，故上述地址所在块地址为`0xa000`，又因为一对伙伴块中地址处于低位的那一块地址应该为512B的偶数倍，得知该块在pair中是地址较低的一块，其伙伴块地址为`0xb000`。

32kb = 2^5 * 2^13
